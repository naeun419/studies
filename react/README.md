1. React 살펴보기
    * React란 무엇인가

        -> UI 컴포넌트 라이브러리

            *   CBA(conponent-based-architecture) VS MVC

                -> CBA의 경우 책임은 구성 컴포넌트 별로 나누어짐(수직적). 이것은 디자인, 로직 및 헬퍼 메소드가 모두 아키텍처의 동일한 레벨(일반적으로 뷰)내에 존재함을 의미

                -> 특정 구성 요소와 관련된 모든 것은 해당 컴포넌트 클래스 내에 정의 됨

                -> 일체형 UI에 비해, 재사용과 유지보수, 확장이 용이함



                -> MVC는 책임을 수평적으로 나눔

                -> angular는 UI를 표시하는 템플릿과 렌더링 할 템플릿을 결정하는 경로 및 헬퍼 기능을 정의하는 서비스를 제공

                -> 템플릿의 경로와 연관 메소드가 있는 경우에도 이등 모두는 어플리케이션 아키텍처의 여러 단계에 존재함
            


    * React의 장점

        -> 간결성

            * 선언형 스타일 채택

            : 명령형 스타일과 달리, 실행 결과가 어떻게 되어야 할지를 코드로 작성해야 함 (What에 집중)

            : 복잡도를 줄여줄 뿐만 아니라 코드에 대한 이해도와 가독성을 높일 수 있기 때문

            : view를 갱신할 때(DOM 비교, 상태와 뷰의 보정), 명령형 스타일(DOM을 직접 조작해야 함)과 달리 개발자는 명시적으로 뷰를 변경하려고 노력할 필요가 없음 => 상태를 갱신하면 뷰는 이에 따라 자동적으로 갱신 됨

            cf) 명령형 스티일 : 결괏값을 구하기 위해 해야 할 과정을 코드로 작성 (How에 집중)



            * 자바스크립트를 이용한 컴포넌트 기반 아키텍쳐

            -> 관심사 분리, 느슨한 결합, 코드 재사용의 장점

                * React는 React.createElement(type, [props], [...children]) API를 통해 컴포넌트 생성

                -> 리액트 컴포넌트는 React.createElement를 통해 엘리먼트에 대한 정보를 가지는 Object를 생성하고 이를 In-Memory에 저장하고, ReactDOM.render 함수를 통해 Web API를 이용해서 실제 웹 브라우저에 그려주는 방식으로 동작

                -> React.createElement(elementName, data, child)

                : elementName => HTML 태그명을 'h1'처럼 문자열로 작성하거나 사용자 정의 컴포넌트 클래스 객체를 넘겨줄 수 있음

                : data => 속성이나 상위 컴포넌트에 받는 값으로 null이나 {name: 'Azat'}와 같은 형태의 데이터

                : child => 자식 엘리먼트나 태그 내부에 작성하는 텍스트



                * arr.map(callback(currentValue[, index[, array]])[, thisArg])

                -> 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환



                ex)     account.map(function(account, index) {      // 배열의 요소 값과 Array.map()이 제공하는 인덱스를 사용

                            return React.createElement('div', {key: index}, account.name)   // 인덱스를 key 속성으로 하고 안에는 account.name을 택스트로 가진 React 엘리먼트 <div/> 를 반환

                        })



            * 강력한 추상화

            -> 내부의 인터페이스는 숨기고, 대신 정규화 과정을 거친 합성 메소드와 속성을 제공



        -> 속도와 테스트 용이성

            : React의 가상 DOM은 자바스크립트 메모리에만 존재. 데이터를 변경하면 React는 가상 DOM을 먼저 비교하고, 렌더링 변경이 필요한 경우에만 실제 DOM에 렌더링 함 (꼭 필요한 부분만 갱신하여 내부 상태(가상 DOM)와 뷰(실제 DOM)를 같게 만듬)

            : 가상 DOM의 장점 => PhantomJS 같은 헤드리스 브라우저(GUI 없이 실행할 수 있는 브라우저) 없이도 단위 테스트가 가능


        -> React 의 폭넓은 개발 커뮤니티와 생태계

            : React의 개발 커뮤니티는 엄청나기 때문에, 대부분 직접 구현할 필요가 없음

    

    * React의 단점

        -> 모든 기능을 갖춘 프레임워크는 아님 (Redux나 Router같은 라이브러리를 함꼐 사용해야 함)

        -> 다른 프레임워크 만큼 성숙하지 않음 (아직 API의 변화가 있음)

        -> 아직 정통한 수준이 될 만한 모범 사례나 자료가 부족함

        -> 단방향 데이터 바인딩만 제공

            : 단방향 바인딩은 복잡한 앱에서 복잡도를 줄이는 데 도움을 주지만 AngularJS 같은 양방향 바인딩에 익숙한 개발자에게는 코드를 더 작상해야 하므로 불편함

        -> 리액티브 프로그래밍이라 볼 수 없음

            : 리액티브 프로그래밍 or 아키텍처는 보다 더 이벤트 기반이고, 탄력과 반응성이 뛰어남. 리액트는 옵저버블을 이용해서 비동기 데이터 스트림을 다루려면 RxJS같은 도구를 사용해야 함




    * 웹 애플리케이션에 React 적용하기

        -> React는 UI 라이브러리일 뿐이므로 어떤 형태의 백엔드나 프론트엔드 데이터 관리 라이브러리와도 함께 사용할 수 있음

        * React 라이브러리와 렌더링 대상

            -> React 커뮤니티는 여러 가지 렌더링 대상에 React를 적용할 수 잇는 패키지를 선보임 (컴포넌트 작성과 렌더링의 분리)



        * 단일 페이지 애플리케이션과 React

            -> 단일 패이지 애플리케이션(SPA) 아키텍쳐는 서버보다는 클라이언트, 즉 브라우저 측에 로직이 더 많은 팻 클라이언트

            -> SPA 아키텍처 동작 과정

                1. 사용자가 새로운 페이지를 열기 위해 브라우저에 URL 입력

                2. 브라우저가 URL 요청을 서버에 전송

                3. 서버는 응답으로 HTML, CSS, 자바스크립트 파일 같은 정적 자원을 보냄

                4. 자바스크립트 로드 후 추가로 AJAX, XHR(XMLHttpRequest, AJAX 요청을 생성하는 JavaScript API) 요청을 보내 서버에서 데이터를 불러옴

                5. 데이터는 JSON, XML 등의 포맷으로 전달받음

                6. SPA에 데이터가 전달되면 UI를 구성하는 HTML을 렌더링 함. SPA는 템플릿에 전달받은 데이터를 밀어넣고 브라우저 상에서 UI를 렌더링 함

            -> 모든 렌더링을 서버에서 해결하는 전통적인 방식과 달리 SPA에서는 데이터만 주고 받음(렌더링은 템플릿으로 HTML을 생성하는 과정)

 


 2. React 첫걸음

    * 엘리먼트 중첩

        -> 계층적 방식으로 더 복잡한 구조를 만드는 방법은 엘리먼트를 중첩하는 것

        -> 실제 DOM에 렌더링 하는 ReactDOm.render()에는 하나의 React 엘리먼트만 인자로 전달할 수 있음

        -> 동일한 DOM 계층에 요소 두 개를 렌더링 해야 하는 경우 문제가 발생

            : 시각적으로 영챵을 끼치지 않는 요소로 두 요소를 감싸는 방법으로 해결 (ex) <div> 또는 <span>을 컨테이너로 사용하는 것)

        -> createElement()에 두번째 매개변수 이후의 모든 매개변수는 자식 엘리먼트가 됨



    * React 컴포넌트 클래스 생성

        -> 컴포넌트 클래스를 이용하면 기능을 느슨하게 결합된 부분으로 분리하여 코드 재사용 가능

            * 느슨한 결합 : 다른 클래스를 직접적으로 사용하는 클래스의 의존성을 줄인 결합

        -> 추상화는 여러 팀이 거대하고 복잡한 애플리케이션에 UI를 재사용하는 것은 물론, 다른 프로젝트에서도 재사용 가능

        -> ES6 문법을 이용하면 React.Component 클래스를 상속받아서 React 컴포넌트 클래스 생성 가능



    * React 속성 사용하기

        -> React 컴포넌트의 속성(Props)은 React 선언형 스타일의 기초 (속성은 컴포넌트 내부에서 변경할 수 없는 값)

        -> <TAG_NAME PROPERTY_NAME=VALUE/>

        -> Props의 용도

            : 일반적인 HTML요소의 속성 (href, titile, style, class etc,,,)

            : React 컴포넌트 클래스의 자바스크립트 코드에서 this.props의 값

            ** 일치하는 HTML 속성이 있으면 해당 엘리먼트의 HTML 속성으로 사용 / 입력한 속성의 이름이 PROPERTY_NAME 이라면 컴포넌트 클래스 코드에서는 this.porps.PROPERTY_NAME으로 접근 가능

            ** 표준 HTML 속성명과 일치하지 않는다면 속성명 이 표준 속성이 아닌것 (HTML에 렌더링 하지 않음) / But, 이 값은 this.props.PROPERTY_NAME 같은 방식으로 접근 가능

        -> 같은 컴포넌트에 다른 속성 값을 입력하면 컴포넌트가 렌더링한 엘리먼트의 모습을 다르게 할 수 있음

        -> 컴포넌트 render() 메서드 내에서 this.props 객체에 접근하면 createElement()의 두번째 매개변수로 전달한 객체에 접근할 수 있음

        -> React.createElement()의 두번째 인자로 전달하는 키-값 쌍의 수는 제한이 없음

        -> 컴포넌트의 모든 속성을 자식 엘리먼트에 넘겨주는 것이 가능






3. JSX

    * JSX의 정의와 장점 

        -> JSX는 함수 호출과 객체 생성을 위한 문법적 편의를 제공하는 자바스크립트의 확장으로, 특히 React.createElement() 호출을 반복해야 하는 불편을 해소

        -> JSX의 장점

        : 개발자 경험 개선 => 표현력이 뛰어나 코드를 읽기 쉽다. XML과 문법이 유사하여 중첩된 선언형 구조를 더 잘 나타냄

        : 팀의 생산성 향상 => JSX는 HTML과 비슷하여 개발지식이 있는 팀원이라면 코드 수정 가능

        : 문법 오류와 코드량 감소 => 작성해야 할 코드가 줄어들며, 실수나 반복을 줄여줌

        -> JSX를 사용하려면 브라우저에서 실행하기 전에 컴파일 또는 트랜스컴파일 과정을 거쳐 일반적인 자바스크립트로 변환해야 함



    * JSX의 이해

        -> JSX에서 속성 사용하기

        : 속성에 하드 코딩한 값을 사용하는 것은 유연하지 않음 (동적으로 생성한 값 사용)

        : 이 값은 컴포넌트 속성(this.props)에서 가져올 수 잇음

        : 이후 화살괄호(<>) 안에 중괄호({})를 작성하여 속성에 동적으로 생성한 값을 엘리먼트에 전달하면 됨


        
        : 때로는 사용자 지정 데이터를 속성으로 추가해야 하는 경우가 있음

            -> DOM의 HTML 비표준 속성에 데이터를 저장하는 것은 일반적으로 안티패턴임 (DOM을 데이터베이스나 프론트엔드 데이터 저장소로 사용하는 것은 적절하지 않기 때문/ 메모리 상의 가상 저장소에서 데이터를 가져오는것 보다 느림)

            -> JSX를 사용할 때 데이터를 반드시 HTML 요소의 속성으로 저장해야 하는 경우에는 data-* 속성을 사용함

            -> 사용자 지정 컴포넌트 클래스에는 내장 렌더러가 없고, 표준 사용자 지정 엘리먼트에 의존하므로 데이터를 다루기 위해 data-* 속성을 사용할 필요는 없음
            
            (this.props를 통해서 입력한 모든 속성에 접근할 수 있기 때문)


        -> React 컴포넌트 메서드 생성하기 

            : React 컴포넌트에 애플리케이션을 위한 메서드 자유롭게 추가 가능 (React 컴포넌트가 클래스기 때문)

        
        -> JSX의 if/else 처리
            
            : return문 이전에 JSX 외부에서 변수를 선언한 후 JSX 내부에서 {}를 사용하여 출력

            : return문 이전에 JSX 외부에서 값을 반환하는 함수 표현식을 선언한 후 JSX 내부의 {}에서 실행

            : 삼항 연산자 사용
            
            : JSX 내부에서 즉시실행함수 사용

        -> JSX의 주석 작성 방법

            : JSX의 주석을 일반 자바스크립트의 주석과 비슷. JSX에 주석을 추가할 때는 표준 자바스크립트의 주석을 {}로 감싸서 작성



    * Babel을 이용한 JSX 트랜스파일러 설정

        -> JSX를 실행하려면 일반적인 자바스크립트 코드로 변환해야 함 => '트랜스파일레이션'

        -> Babel 의 주요 기능은 ES6 + /ES2015 + 컴파일러이지만, JSX를 자바스크립트로 변환하기도 함

    

    * React 와 JSX의 까다로운 부분

        -> 특수 문자

        : HTML 엔터티 코드를 사용하여 저작권 표시나 말바꿈표, 따옴표 등 특수문자를 표시

        : React/JSX는 위험한 HTML 구문에 대해 자동으로 이스케이프를 적용

        -> data-속성

        : React는 주로 HTML 비표준속성을 컴포넌트에 추가하면 무시함(React 동작 원리)

        : DOM 노드에 추가 데이터를 전달해야 하는 경우(안티패턴 - DOM을 데이터베이스나 로컬 스토리지처럼 ㅅ용하지 말아야함)

          But, 사용자 정의 속성을 렌더링해야 한다면, 속성의 접두사로 data-를 사용

          ex) <li data-object-id="097F4E4F">...</li>

        -> style 속성

        : JSX의 스타일 속성은 일반적인 HTML과 다르게 동작. JSX에서는 문자열 대신 자바스크립트 객체를 전달하고(React가 뷰를 더 빠르게 변경하기 때문), CSS 속성은 카멜 표기법을 작성

        ex) <span style={{borderColor: 'red',
              borderWidth: 1,
              borderStyle: 'solid'}}>Hey</span>
        
            <span style={{border: '1px red solid'}}>Hey</span>

        -> class 와 for 속성

        : React와 JSX는 class와 for를 제외하면 표준 HTML 속성을 모두 사용할 수 있음

        : class와 for는 자바스크립트와 ECMAScript의 예약어이고, JSX는 일반 자바스크립트로 변환해서 사용함
          따라서 class와 for 대신에 각각 className과 htmlFor를 사용

        -> bool 값을 속성으로 사용하는 경우

        : disabled, required, checked, autuFocus, readOnly 같은 일부 속성은 폼 요소에만 사용함
        (속성 값을 {}안에 반드시 자바스크립트 식으로 작성해야 함, 문자열 입력 X)

