1. React 살펴보기
    * React란 무엇인가

        -> UI 컴포넌트 라이브러리

            *   CBA(conponent-based-architecture) VS MVC

                -> CBA의 경우 책임은 구성 컴포넌트 별로 나누어짐(수직적). 이것은 디자인, 로직 및 헬퍼 메소드가 모두 아키텍처의 동일한 레벨(일반적으로 뷰)내에 존재함을 의미

                -> 특정 구성 요소와 관련된 모든 것은 해당 컴포넌트 클래스 내에 정의 됨

                -> 일체형 UI에 비해, 재사용과 유지보수, 확장이 용이함



                -> MVC는 책임을 수평적으로 나눔

                -> angular는 UI를 표시하는 템플릿과 렌더링 할 템플릿을 결정하는 경로 및 헬퍼 기능을 정의하는 서비스를 제공

                -> 템플릿의 경로와 연관 메소드가 있는 경우에도 이등 모두는 어플리케이션 아키텍처의 여러 단계에 존재함
            


    * React의 장점

        -> 간결성

            * 선언형 스타일 채택

            : 명령형 스타일과 달리, 실행 결과가 어떻게 되어야 할지를 코드로 작성해야 함 (What에 집중)

            : 복잡도를 줄여줄 뿐만 아니라 코드에 대한 이해도와 가독성을 높일 수 있기 때문

            : view를 갱신할 때(DOM 비교, 상태와 뷰의 보정), 명령형 스타일(DOM을 직접 조작해야 함)과 달리 개발자는 명시적으로 뷰를 변경하려고 노력할 필요가 없음 => 상태를 갱신하면 뷰는 이에 따라 자동적으로 갱신 됨

            cf) 명령형 스티일 : 결괏값을 구하기 위해 해야 할 과정을 코드로 작성 (How에 집중)



            * 자바스크립트를 이용한 컴포넌트 기반 아키텍쳐

            -> 관심사 분리, 느슨한 결합, 코드 재사용의 장점

                * React는 React.createElement(type, [props], [...children]) API를 통해 컴포넌트 생성

                -> 리액트 컴포넌트는 React.createElement를 통해 엘리먼트에 대한 정보를 가지는 Object를 생성하고 이를 In-Memory에 저장하고, ReactDOM.render 함수를 통해 Web API를 이용해서 실제 웹 브라우저에 그려주는 방식으로 동작

                -> React.createElement(elementName, data, child)

                : elementName => HTML 태그명을 'h1'처럼 문자열로 작성하거나 사용자 정의 컴포넌트 클래스 객체를 넘겨줄 수 있음

                : data => 속성이나 상위 컴포넌트에 받는 값으로 null이나 {name: 'Azat'}와 같은 형태의 데이터

                : child => 자식 엘리먼트나 태그 내부에 작성하는 텍스트



                * arr.map(callback(currentValue[, index[, array]])[, thisArg])

                -> 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환



                ex)     account.map(function(account, index) {      // 배열의 요소 값과 Array.map()이 제공하는 인덱스를 사용

                            return React.createElement('div', {key: index}, account.name)   // 인덱스를 key 속성으로 하고 안에는 account.name을 택스트로 가진 React 엘리먼트 <div/> 를 반환

                        })



            * 강력한 추상화

            -> 내부의 인터페이스는 숨기고, 대신 정규화 과정을 거친 합성 메소드와 속성을 제공



        -> 속도와 테스트 용이성

            : React의 가상 DOM은 자바스크립트 메모리에만 존재. 데이터를 변경하면 React는 가상 DOM을 먼저 비교하고, 렌더링 변경이 필요한 경우에만 실제 DOM에 렌더링 함 (꼭 필요한 부분만 갱신하여 내부 상태(가상 DOM)와 뷰(실제 DOM)를 같게 만듬)

            : 가상 DOM의 장점 => PhantomJS 같은 헤드리스 브라우저(GUI 없이 실행할 수 있는 브라우저) 없이도 단위 테스트가 가능


        -> React 의 폭넓은 개발 커뮤니티와 생태계

            : React의 개발 커뮤니티는 엄청나기 때문에, 대부분 직접 구현할 필요가 없음

    

    * React의 단점

        -> 모든 기능을 갖춘 프레임워크는 아님 (Redux나 Router같은 라이브러리를 함꼐 사용해야 함)

        -> 다른 프레임워크 만큼 성숙하지 않음 (아직 API의 변화가 있음)

        -> 아직 정통한 수준이 될 만한 모범 사례나 자료가 부족함

        -> 단방향 데이터 바인딩만 제공

            : 단방향 바인딩은 복잡한 앱에서 복잡도를 줄이는 데 도움을 주지만 AngularJS 같은 양방향 바인딩에 익숙한 개발자에게는 코드를 더 작상해야 하므로 불편함

        -> 리액티브 프로그래밍이라 볼 수 없음

            : 리액티브 프로그래밍 or 아키텍처는 보다 더 이벤트 기반이고, 탄력과 반응성이 뛰어남. 리액트는 옵저버블을 이용해서 비동기 데이터 스트림을 다루려면 RxJS같은 도구를 사용해야 함




    * 웹 애플리케이션에 React 적용하기

        -> React는 UI 라이브러리일 뿐이므로 어떤 형태의 백엔드나 프론트엔드 데이터 관리 라이브러리와도 함께 사용할 수 있음

        * React 라이브러리와 렌더링 대상

            -> React 커뮤니티는 여러 가지 렌더링 대상에 React를 적용할 수 잇는 패키지를 선보임 (컴포넌트 작성과 렌더링의 분리)



        * 단일 페이지 애플리케이션과 React

            -> 단일 패이지 애플리케이션(SPA) 아키텍쳐는 서버보다는 클라이언트, 즉 브라우저 측에 로직이 더 많은 팻 클라이언트

            -> SPA 아키텍처 동작 과정

                1. 사용자가 새로운 페이지를 열기 위해 브라우저에 URL 입력

                2. 브라우저가 URL 요청을 서버에 전송

                3. 서버는 응답으로 HTML, CSS, 자바스크립트 파일 같은 정적 자원을 보냄

                4. 자바스크립트 로드 후 추가로 AJAX, XHR(XMLHttpRequest, AJAX 요청을 생성하는 JavaScript API) 요청을 보내 서버에서 데이터를 불러옴

                5. 데이터는 JSON, XML 등의 포맷으로 전달받음

                6. SPA에 데이터가 전달되면 UI를 구성하는 HTML을 렌더링 함. SPA는 템플릿에 전달받은 데이터를 밀어넣고 브라우저 상에서 UI를 렌더링 함

            -> 모든 렌더링을 서버에서 해결하는 전통적인 방식과 달리 SPA에서는 데이터만 주고 받음(렌더링은 템플릿으로 HTML을 생성하는 과정)

 


 2. React 첫걸음

    * 엘리먼트 중첩

        -> 계층적 방식으로 더 복잡한 구조를 만드는 방법은 엘리먼트를 중첩하는 것

        -> 실제 DOM에 렌더링 하는 ReactDOM.render()에는 하나의 React 엘리먼트만 인자로 전달할 수 있음

        -> 동일한 DOM 계층에 요소 두 개를 렌더링 해야 하는 경우 문제가 발생

            : 시각적으로 영챵을 끼치지 않는 요소로 두 요소를 감싸는 방법으로 해결 (ex) <div> 또는 <span>을 컨테이너로 사용하는 것)

        -> createElement()에 두번째 매개변수 이후의 모든 매개변수는 자식 엘리먼트가 됨



    * React 컴포넌트 클래스 생성

        -> 컴포넌트 클래스를 이용하면 기능을 느슨하게 결합된 부분으로 분리하여 코드 재사용 가능

            * 느슨한 결합 : 다른 클래스를 직접적으로 사용하는 클래스의 의존성을 줄인 결합

        -> 추상화는 여러 팀이 거대하고 복잡한 애플리케이션에 UI를 재사용하는 것은 물론, 다른 프로젝트에서도 재사용 가능

        -> ES6 문법을 이용하면 React.Component 클래스를 상속받아서 React 컴포넌트 클래스 생성 가능



    * React 속성 사용하기

        -> React 컴포넌트의 속성(Props)은 React 선언형 스타일의 기초 (속성은 컴포넌트 내부에서 변경할 수 없는 값)

        -> <TAG_NAME PROPERTY_NAME=VALUE/>

        -> Props의 용도

            : 일반적인 HTML요소의 속성 (href, titile, style, class etc,,,)

            : React 컴포넌트 클래스의 자바스크립트 코드에서 this.props의 값

            ** 일치하는 HTML 속성이 있으면 해당 엘리먼트의 HTML 속성으로 사용 / 입력한 속성의 이름이 PROPERTY_NAME 이라면 컴포넌트 클래스 코드에서는 this.porps.PROPERTY_NAME으로 접근 가능

            ** 표준 HTML 속성명과 일치하지 않는다면 속성명 이 표준 속성이 아닌것 (HTML에 렌더링 하지 않음) / But, 이 값은 this.props.PROPERTY_NAME 같은 방식으로 접근 가능

        -> 같은 컴포넌트에 다른 속성 값을 입력하면 컴포넌트가 렌더링한 엘리먼트의 모습을 다르게 할 수 있음

        -> 컴포넌트 render() 메서드 내에서 this.props 객체에 접근하면 createElement()의 두번째 매개변수로 전달한 객체에 접근할 수 있음

        -> React.createElement()의 두번째 인자로 전달하는 키-값 쌍의 수는 제한이 없음

        -> 컴포넌트의 모든 속성을 자식 엘리먼트에 넘겨주는 것이 가능






3. JSX

    * JSX의 정의와 장점

        -> JSX는 함수 호출과 객체 생성을 위한 문법적 편의를 제공하는 자바스크립트의 확장으로, 특히 React.createElement() 호출을 반복해야 하는 불편을 해소

        -> JSX의 장점

        : 개발자 경험 개선 => 표현력이 뛰어나 코드를 읽기 쉽다. XML과 문법이 유사하여 중첩된 선언형 구조를 더 잘 나타냄

        : 팀의 생산성 향상 => JSX는 HTML과 비슷하여 개발지식이 있는 팀원이라면 코드 수정 가능

        : 문법 오류와 코드량 감소 => 작성해야 할 코드가 줄어들며, 실수나 반복을 줄여줌

        -> JSX를 사용하려면 브라우저에서 실행하기 전에 컴파일 또는 트랜스컴파일 과정을 거쳐 일반적인 자바스크립트로 변환해야 함



    * JSX의 이해

        -> JSX에서 속성 사용하기

        : 속성에 하드 코딩한 값을 사용하는 것은 유연하지 않음 (동적으로 생성한 값 사용)

        : 이 값은 컴포넌트 속성(this.props)에서 가져올 수 잇음

        : 이후 화살괄호(<>) 안에 중괄호({})를 작성하여 속성에 동적으로 생성한 값을 엘리먼트에 전달하면 됨



        : 때로는 사용자 지정 데이터를 속성으로 추가해야 하는 경우가 있음

            -> DOM의 HTML 비표준 속성에 데이터를 저장하는 것은 일반적으로 안티패턴임 (DOM을 데이터베이스나 프론트엔드 데이터 저장소로 사용하는 것은 적절하지 않기 때문/ 메모리 상의 가상 저장소에서 데이터를 가져오는것 보다 느림)

            -> JSX를 사용할 때 데이터를 반드시 HTML 요소의 속성으로 저장해야 하는 경우에는 data-* 속성을 사용함

            -> 사용자 지정 컴포넌트 클래스에는 내장 렌더러가 없고, 표준 사용자 지정 엘리먼트에 의존하므로 데이터를 다루기 위해 data-* 속성을 사용할 필요는 없음

            (this.props를 통해서 입력한 모든 속성에 접근할 수 있기 때문)


        -> React 컴포넌트 메서드 생성하기

            : React 컴포넌트에 애플리케이션을 위한 메서드 자유롭게 추가 가능 (React 컴포넌트가 클래스기 때문)


        -> JSX의 if/else 처리

            : return문 이전에 JSX 외부에서 변수를 선언한 후 JSX 내부에서 {}를 사용하여 출력

            : return문 이전에 JSX 외부에서 값을 반환하는 함수 표현식을 선언한 후 JSX 내부의 {}에서 실행

            : 삼항 연산자 사용

            : JSX 내부에서 즉시실행함수 사용

        -> JSX의 주석 작성 방법

            : JSX의 주석을 일반 자바스크립트의 주석과 비슷. JSX에 주석을 추가할 때는 표준 자바스크립트의 주석을 {}로 감싸서 작성



    * Babel을 이용한 JSX 트랜스파일러 설정

        -> JSX를 실행하려면 일반적인 자바스크립트 코드로 변환해야 함 => '트랜스파일레이션'

        -> Babel 의 주요 기능은 ES6 + /ES2015 + 컴파일러이지만, JSX를 자바스크립트로 변환하기도 함



    * React 와 JSX의 까다로운 부분

        -> 특수 문자

        : HTML 엔터티 코드를 사용하여 저작권 표시나 말바꿈표, 따옴표 등 특수문자를 표시

        : React/JSX는 위험한 HTML 구문에 대해 자동으로 이스케이프를 적용

        -> data-속성

        : React는 주로 HTML 비표준속성을 컴포넌트에 추가하면 무시함(React 동작 원리)

        : DOM 노드에 추가 데이터를 전달해야 하는 경우(안티패턴 - DOM을 데이터베이스나 로컬 스토리지처럼 ㅅ용하지 말아야함)

          But, 사용자 정의 속성을 렌더링해야 한다면, 속성의 접두사로 data-를 사용

          ex) <li data-object-id="097F4E4F">...</li>

        -> style 속성

        : JSX의 스타일 속성은 일반적인 HTML과 다르게 동작. JSX에서는 문자열 대신 자바스크립트 객체를 전달하고(React가 뷰를 더 빠르게 변경하기 때문), CSS 속성은 카멜 표기법을 작성

        ex) <span style={{borderColor: 'red',
              borderWidth: 1,
              borderStyle: 'solid'}}>Hey</span>

            <span style={{border: '1px red solid'}}>Hey</span>

        -> class 와 for 속성

        : React와 JSX는 class와 for를 제외하면 표준 HTML 속성을 모두 사용할 수 있음

        : class와 for는 자바스크립트와 ECMAScript의 예약어이고, JSX는 일반 자바스크립트로 변환해서 사용함
          따라서 class와 for 대신에 각각 className과 htmlFor를 사용

        -> bool 값을 속성으로 사용하는 경우

        : disabled, required, checked, autuFocus, readOnly 같은 일부 속성은 폼 요소에만 사용함
        (속성 값을 {}안에 반드시 자바스크립트 식으로 작성해야 함, 문자열 입력 X)




4. React 컴포넌트의 상태 객체

    -> 속성을 변경하여 뷰를 갱신할 수 있지만, 속성은 현재 컴포넌트 내부에서는 수정할 수 없음 (속성은 해당 컴포넌트 생성 시에 전달받는 값이기 때문)
       속성을 변경할 수 없는 경우 어떻게 해야 할까...?   뷰를 변경하기 위해서는 컴포넌트 내부에 변경할 수 잇는 다른 자료형이 필요 ==> 상태 객체 이용

    -> 서버 응답에 따라 콜백 코드가 컴포넌트의 상태를 변경
        상태(state)는 React 컴포넌트에 데이터를 저장하고, 데이터의 변경에 따라 자동으로 뷰를 갱신하도록 하는 핵심 개념

    * React 컴포넌트의 상태란?

        -> React의 state는 컴포넌트의 변경 가능한 데이터 저장소

        -> 컴포넌트를 속성과 상태가 있는 함수라고 생각하면 이 함수의 결과가 UI 표현(뷰)

        -> 상태 객체에 접근할 때는 이름을 이용. 이름은 this.state 객체의 속성

        -> React 개발자는 상태 객체를 이용해서 새로운 UI를 생성. 컴포넌트 속성(this.props)이나, 일반적인 변수(inputValue), 클래스 속성(this.inputValue)으로는 처리할 수 없는데, 이것들을 현재 컴포넌트 내부에서 변경하더라도 뷰를 자동으로 변경할 수 없기 때문

        ** 속성은 부모 컴포넌트에서 새로운 값을 전달하면 뷰를 갱신하여 현재 다루고 있는 자식 컴포넌트의 새로운 인스턴스를 생성함. 해당 자식 컴포넌트의 컨텍스트 내에서 this.props.inputValue = 'California' 같은 방식으로 속성을 변경하려고 해도 소용 없음

    * 상태 객체 다루기

        -> 상태 객체는 컴포넌트의 멤버 변수로 this를 통해 접근 (render()에서 this.state를 렌더링 할 수 있음)
        ex) this.state.name 

            * 초기 상태 설정하기

            -> render()에서 상태 데이터를 사용하려면 먼저 상태를 초기화해야 함
            상태를 설정하려면 React.Component를 사용하는 ES6 클래스의 생성자에서 this.state를 선언함. 반드시 super()에 속성을 전달하여 실행해야 함 (그렇지 않으면 부모 클래스 React.Component의 기능을 정상적으로 사용할 수 없음)

            -> 여기서 this.state의 값은 반드시 객체
            ** 객체지향 프로그래밍 언어에서 클래스의 인스턴스가 생성될 때 constructor()가 호출됨
            또한, 부모 클래스가 있는 클래스에서 constructor() 메서드를 생성하면 그 안에서 거의 항상 super()를 호출 (그렇지 않으면 부모 클래스의 생성자가 실행되지 않음)
            상속으로 클래스를 구현하는 경우에 constructor() 메서드를 따로 작성하지 않으면 super()를 호출한 것으로 가정
       
            -> constructor() 메서드는 앞의 컴포넌트 클래스에서 React 엘리먼트가 생성되는 시점에 한 번만 호출됨. 이렇게 constructor() 메서드 내에서 한 번만 this.state로 직접 상태를 선언할 수 있음
            ** 이렇게하면 첫번째 값을 입력해서 보여줄 뿐, But React에는 상태를 갱신하는 방법도 있음ㅋ

            * 상태 갱신하기
             
             -> 클래스 메서드인 this.setState(data, callback)를 사용하면 상태를 변경할 수 있음. 이 메서드를 실행하면 react는 전달하는 메서드를 현재 상태에 병합하고 render()를 호출함. 이후에 React가 callback 함수를 실행함 (setState는 비동기로 작동)

             -> setState()가 완료되길 기다리지 않고 새로운 상태에 의존하는 작업을 수행하는 것은 비동기 작업을 동기처럼 다루는 것. 이 경우 갱신될 새로운 상태 값에 의존하는 코드를 작성하면 버그가 생길 수 있는데, 상태 객체가 이전 값을 가진 이전의 상태 객체로 남아있기 때문

             -> 일반적으로 setState()는 이벤트 핸들러나 데이터 수신 또는 갱신을 처리하는 콜백함수에서 호출됨

             -> setState()에서 매번 상태 객체를 완전히 바꾸지 않음(일부분만 수정하거나 병합)

             -> setState()가 render()를 실행시킴

             ** JSX에서 값을 출력할 때는 중괄호({}) 사용. 그러므로 뷰에서 render() 문에서 {this.state.NAME}를 사용



    * 상태 객체와 속성

    -> 상태 객체와 속성은 모두 클래스의 멤버이며, 각각 this.state와 this.props를 말함 
    
    -> But, 상태 객체는 변경 가능한 반면, 속성은 변경 불가능 함
       또한, 속성은 부모 컴포넌트에서 전달하지만, 상태는 부모 컴포넌트가 아닌 해당 컴포넌트 자체에서 정의함 (속성 값을 변경하는 것은 오직 부모 컴포넌트에서만 가능하고, 자체적으로 변경할 수 없음 => 속성은 뷰 생성 시에 정해지고, 정적인 상태로 유지됨 / 상태는 해당 컴포넌트에서 설정되고 갱신됨)


    * 상태비저장 컴포넌트

    -> 상태비저장 컴포넌트(stateless component)는 상태 객체가 없으며, 컴포넌트 메서드 또는 다른 React 라이프사이클 이벤트 또는 메서드를 갖지 않음

    -> 상태비저장 컴포넌트는 속성을 입력받아 UI 엘리먼트를 출력하는 간단한 함수

    -> 상태비저장 컴포넌트는 출력을 결정하는 입력이 한 가지 뿐이라 예측할 수 있다는 이점이 있음 (유지보수와 디버깅이 편리함)

    -> React는 함수형 스타일을 사용하여 인자로 속성을 전달받아 뷰를 반환하는 함수를 생성할 수 있음 (보통 함수나 화살표 함수 문법으로 작성한 컴포넌트)
        => 상태비저장 컴포넌트를 생성하려면 함수로 선언해라!

    -> 상태비저장 컴포넌트는 propTypes와 defaultProps를 프로퍼티로 가질 수 있음

    * 상태비저장 컴포넌트와 상태저장 컴포넌트의 비교

    -> 상태 저장은 적을 수록, 상태비저장 컴포넌트는 많이 사용할 수록 좋음

    -> 상태비저장 컴포넌트의 사용 이유

        : HTML 렌더링을 처리하는 것으로 충분한 경우, 별도의 인스턴스를 생성하거나, 라이프사이클 메서드를 사용하지 않아도 되는 상태비저장 컴포넌트가 더 선언적으로 작동

        : 중복을 줄일 수 있고, 더 나은 문법을 바탕으로 좀 더 간결하게 컴포넌트를 작성할 수 있음

    -> 상태비저장 컴포넌트가 반드시 정적인 것음 아님, 다른 속성을 전달하면 상태비저장 컴포넌트의 모습을 바꿀 수 있음

    -> 단순하게 유지해야 함. 상태 객체나 메서드를 추가하지 않아야 함


5. React 컴포넌트 라이프사이클 이벤트

    -> React는 라이프사이클 이벤트를 기반으로 컴포넌트의 동작을 제어하고, 사용자 정의를 할 수 있음

    -> 라이프사이클 이벤트 종류

    -> 라이프사이클 이벤트는 컴포넌트가 수행한 작업이나 앞으로 수행할 작업에 따라 특정 시점에  실행됨

    * 이벤트 분류

    : 마운팅 이벤트 
            => React 엘리먼트(컴포넌트 클래스의 인스턴스)를 DOM에 추가할 때 발생 / React가 이벤트를 한 번만 실행

        : 갱신 이벤트
            => 속성이나 상태가 변경되어 React 엘리먼트를 갱신할 때 발생함 / React가 이벤트를 여러 번 실행

        : 언마운팅 이벤트 
            => React 엘리먼트를 DOM에서 제거할 때 발생함 / React가 이벤트를 한 번만 실행
    
    -> 라이프사이클의 실행 순서

        (마운트)

        : constructor()

        : static getDerivedStateFromProps()

        : render()

        : componentDidMount()

        (업데이트)

        : static getDerivedStateFromProps()

        : shouldConponentUpdate()

        : render()

        : getSnapshotBeforeUpdate()

        : componentDidUpdate()

        (마운트 해제)

        : componentWillUnmount()

        ** 순수함수

        -> 같은 입력에 대해 항상 같은 출력

        -> 부수효과가 없음 (외부 상태를 변경하지 않음)

        -> 외부 상태에 의존하지 않음

    * 이벤트 구현

    -> 메서드 이름은 이벤트 이름과 일치해야 함

    -> 컴포넌트 라이프사이클 이벤트에 대한 이벤트 리스너를 생성하는 것은 컴포넌트나 클래스에 메서드를 정의하면 됨

    * 자주 사용되는 생명주기 메서드

        * render()

        -> 해당 메서드 호출시 this.props, this.state의 값을 활용하여 React 엘리먼트, 배열과 Fragment, Portal, 문자열과 숫자, Boolean 또는 null 중 하나를 반환해야 함

        -> render() 함수는 순수해야 함. 즉, 컴포넌트의 state를 변경하지 않고, 호출될 때마다 동일한 결과를 반환해야 하며, 브라우저와 직접적으로 상호작용 하지 않음

        -> render()에서 setState()를 호출하면 무한루프에 빠짐

        * constructor()

        -> 메서드를 바인딩하거나 state를 초기화하는 작업이 없다면, 해당 React 컴포넌트에는 생성자를 구현하지 않아도 됨

        -> 생상자의 목적

        : this.state에 객체를 할당하여 지역 state 초기화

        : 인스턴스에 이벤트 처리 메서드를 바인딩

        -> constructor 내부에서 setState() 호출 말고, this.state에 초기 state 값을 할당해야 함

        ** state에 props를 복사하면 안됨

    * 마운팅 이벤트

    -> 마운팅 이벤트 유형은 모두 실제 DOM에 컴포넌트를 추가하는 것에 대한 이벤트 (React 엘리먼트가 DOM에 노출되는 것)

    : componentDidMount() : React 엘리먼트를 실제 DOM에 추가한 시점으로, 이 시점의 React 엘리먼트는 DOM 노드

    -> constructor()가 먼저 실행됨

    -> React는 엘리먼트를 먼저 렌더링하고 나서 DOM에 추가함 (여기서 말하는 렌더링은 컴포넌트 클래스의 render()를 호출하는 것을 말하며, 실제 DOM에 그리는 것이 아님)

        * componentWillMount()  ===> 현재 deprecated!

        -> ReactDOM.render()를 호출해서 React 엘리먼트를 브라우저에 렌더링하는 시점에서 componentWillMount()가 실행됨

        -> React 컴포넌트를 서버에서 렌더링하면 기본적으로 HTML 문자열을 얻을 수 있는데, 서버에는 DOM이 없으므로 HTML을 DOM에 추가하는 작업은 없지만, 서버 렌더링 과정에서도 componentWillMount()는 실행됨

        -> componentWillMount()에서 갱신하는 새로운 상태에 차이점이 있어도 재렌더링 되지 않음. render()에서 새로운 상태 값을 가져오기 때문 (componentWillMount()에서 setState()를 실행할 수 있음)

        * componentDidMount()

        -> 컴포넌트가 마운트된 직후 (트리에 삽입된 직후), DOM 노드가 있어야 하는 초기화 작업은 이 메서드에서 이루어져야 함

        -> 외부에서 데이터를 불러와야 한다면, 네트워크 요청을 보내기 위한 적절한 위치

        -> componentDidMount()는 초기 렌더링을 마친 후에 실행됨. 또한, 브라우저에서 한 번 실행되고 서버 렌더링에서는 실행되지 않음

        -> componentDidMount()에서 자식 엘리먼트를 참조로 접근할 수 있음

        -> 자식 컴포넌트의 componentDidMount() 메서드는 부모 컴포넌트의 componentDidMount() 보다 먼저 호출됨

        -> componentDidMount()에서 DOM 요소에 접근할 수 있고, 새로운 fetch() API를 이용해서 XHR/AJAX 요청을 보내 데이터를 가져올 수 있음

        ** Fetch API
        => promise를 이용해 XHR 요청을 보낼 수 있는 통일된 방식


    * 갱신 이벤트

        * componentWillReceiveProps(newProps)     ===> 현재 deprecated!! (getDerivedStateFromProps로 대체됨)

        -> 컴포넌트가 새로운 속성을 전달받을 때 실행 됨 (들어오는 속성의 전환) => 컴포넌트를 최초로 렌더링할 때는 실행되지 않음

        -> 컴포넌트에 새로운 속성을 받아오는 시점에 끼어들어서 render()를 호출하기 전에 일부 로직을 추가할 수 있음

        -> componentWillReceiveProps(newProps)에서 setState() 메서드를 호출해도 추가로 다시 렌더링이 발생하지 않음

        -> componentWillReceiveProps(newProps)는 속성 값의 변경과 상관없이(부모 구조 또는 호출에 따라) 재렌더링이 이뤄질 때마다 실행됨
            => React 입장에서는 속성 값이 변경되었는지 알 수 있는 방법이 없음

            ** 재렌더링이 반드시 실제 DOM의 변경을 의미하진 않음

            ** 갱신 여부와 실제 DOM에서 무엇을 갱신할지는 shouldComponentUpdate()와 보정 과정에 위임됨

        * static getDerivedStateFromProps(nextProps, prevState)

        -> 최초 마운트 시와 갱신 시 모두에서 render 메서드를 호출하기 직전에 호출됨

        -> state를 갱신하기 위한 객체를 반환하거나, null을 반환하여 아무 것도 갱신하지 않을 수 있음

        -> 이 메서드는 컴포넌트 인서턴스에 접근할 수 없음. 인스턴스 접근이 필요하다면, class 정의 외부에서 컴포넌트의 props와 state에 대한 순수 함수를 추출하여 getDerivedFromProps()와 다른 클래스 메서드 간에 코드 공유 및 재사용 할 수 있음

        * shouldComponentUpdate()

        -> 현재 state 또는 props가 변화가 컴포넌트의 출력 결과에 영향을 미치는지 여부를 React가 알 수 있음

        -> props 또는 state가  새로운 값으로 갱신되어서 렌더링 직전에 실행되나, 초기 렌더링 시점이나 forceUpdate() 호출 시에는 실행되지 않음

            ** forceUpdate()

            : state나 props가 아닌, 다른 data를 통해서 ,render() 함수가 동작하게 되어 잇는 경우 React의 기본적인 component life cycle 과 무관하기 때문에, 직접 React 에게 해당 component가 re-rendering 되야 한다고 알려야 함. 이때 사용 가능한 함수


        -> shouldComponentUpdate()에서 false를 반환하도록 구현하면 React가 다시 렌더링 되지 않아서 성능 저하를 피할 수 있음 (성능 최적화를 위한 함수)
            => 컴포넌트의 재렌더링을 제어할 수 있는 함수 / false를 반환할 경우 componentWillUpdate(), componentDidUpdate()도 호출하지 않음

        * componentWillUpdate()    ===> deprecated!!

        -> 새로운 속성이나 상태를 받은 후 렌더링 직전에 호출됨 (초기 렌더링 시에는 호출되지 않음)

        -> componentWillUpdate() 메서드를 사용하고, 이 메서드 내에서 this.setState()를 사용하는 것은 피해라
            => 컴포넌트를 갱신하는 중에 다시 갱신하기 때문

        * componentDidUpdate(prevProps, prevState, snapshot)

        -> 컴포넌트의 갱신 결과가 실제 DOM에 반영된 직후에 실행됨 (초기 렌더링 시에는 호출되지 않음)

        -> 컴포넌트가 갱신되었을 때 DOM을 조작하기 위해 / 이전과 현재의 props를 비교하여 네트워크 요청을 보내는 작업을 이 메서드에서 수행하면 됨 (props의 비교)

        -> componentDidUpdate()에서 setState()를 즉시 호출할 수도 있지만, 조건문으로 감싸지 않으면 무한 반복이 발생할 수 있음

        -> 컴포넌트에서 getSnapshotBeforeUpdate()를 구현한다면, 해당 메서드가 반환하는 값은 componentDidUpdate()에 세 번째 
        'snapshot' 인자로 넘겨짐

        * getSnapshotBeforeUpdate(prevProps, prevState)

        -> 가장 마지막으로 렌더링된 결과가 DOM 등에 반영되었을 때에 호출됨

        -> 해당 메서드 사용 시 컴포넌트가 DOM으로부터 스크롤 위치 등과 같은 정보를 이후 변경되기 전에 얻을 수 있음

        -> 이 lifecycle이 반환하는 값은 componentDidUpdate()에 인자로 전달됨

        -> 스냅샷 값 반환하거나 null을 반환함


    * 언마운팅 이벤트

        * componentWillUnmount()

        -> DOM에서 컴포넌트가 제거되기 직전에 호출 됨

        -> 정리하기 위한 코드를 이메서드에 추가 가능 (ex) 타이머 제거, 네트워크 요청 취소, DOM요소 정리, componentDidMount()애서 연결한 이벤트를 제거 가능)


    * 이외의 lifecycle 메서드

        * componentDidCatch(error, info)

        -> 해당 메서드는 자손 컴포넌트에서 오류가 발생했을 때 호출됨

        -> error: 발생한 오류 / info: 어떤 컴포넌트가 오류를 발생시켰는지에 대한 정보를 포함한 componentStack 키를 갖고 있는 객체

    * 기타 API

        * setState()

        -> 