1. React 살펴보기
    * React란 무엇인가
        -> UI 컴포넌트 라이브러리
            *   CBA(conponent-based-architecture) VS MVC
                -> CBA의 경우 책임은 구성 컴포넌트 별로 나누어짐(수직적). 이것은 디자인, 로직 및 헬퍼 메소드가 모두 아키텍처의 동일한 레벨(일반적으로 뷰)내에 존재함을 의미
                -> 특정 구성 요소와 관련된 모든 것은 해당 컴포넌트 클래스 내에 정의 됨
                -> 일체형 UI에 비해, 재사용과 유지보수, 확장이 용이함

                -> MVC는 책임을 수평적으로 나눔
                -> angular는 UI를 표시하는 템플릿과 렌더링 할 템플릿을 결정하는 경로 및 헬퍼 기능을 정의하는 서비스를 제공
                -> 템플릿의 경로와 연관 메소드가 있는 경우에도 이등 모두는 어플리케이션 아키텍처의 여러 단계에 존재함
            
    * React의 장점
        -> 간결성
            * 선언형 스타일 채택
            : 명령형 스타일과 달리, 실행 결과가 어떻게 되어야 할지를 코드로 작성해야 함 (What에 집중)
            : 복잡도를 줄여줄 뿐만 아니라 코드에 대한 이해도와 가독성을 높일 수 있기 때문
            : view를 갱신할 때(DOM 비교, 상태와 뷰의 보정), 명령형 스타일(DOM을 직접 조작해야 함)과 달리 개발자는 명시적으로 뷰를 변경하려고 노력할 필요가 없음 => 상태를 갱신하면 뷰는 이에 따라 자동적으로 갱신 됨
            cf) 명령형 스티일 : 결괏값을 구하기 위해 해야 할 과정을 코드로 작성 (How에 집중)

            * 자바스크립트를 이용한 컴포넌트 기반 아키텍쳐
            -> 관심사 분리, 느슨한 결합, 코드 재사용의 장점

                * React는 React.createElement(type, [props], [...children]) API를 통해 컴포넌트 생성
                -> 리액트 컴포넌트는 React.createElement를 통해 엘리먼트에 대한 정보를 가지는 Object를 생성하고 이를 In-Memory에 저장하고, ReactDOM.render 함수를 통해 Web API를 이용해서 실제 웹 브라우저에 그려주는 방식으로 동작
                -> React.createElement(elementName, data, child)
                : elementName => HTML 태그명을 'h1'처럼 문자열로 작성하거나 사용자 정의 컴포넌트 클래스 객체를 넘겨줄 수 있음
                : data => 속성이나 상위 컴포넌트에 받는 값으로 null이나 {name: 'Azat'}와 같은 형태의 데이터
                : child => 자식 엘리먼트나 태그 내부에 작성하는 텍스트

                * arr.map(callback(currentValue[, index[, array]])[, thisArg])
                -> 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환

                ex)     account.map(function(account, index) {      // 배열의 요소 값과 Array.map()이 제공하는 인덱스를 사용
                            return React.createElement('div', {key: index}, account.name)   // 인덱스를 key 속성으로 하고 안에는 account.name을 택스트로 가진 React 엘리먼트 <div/> 를 반환
                        })

            * 강력한 추상화
            -> 내부의 인터페이스는 숨기고, 대신 정규화 과정을 거친 합성 메소드와 속성을 제공


        -> 속도와 테스트 용이성
            : React의 가상 DOM은 자바스크립트 메모리에만 존재. 데이터를 변경하면 React는 가상 DOM을 먼저 비교하고, 렌더링 변경이 필요한 경우에만 실제 DOM에 렌더링 함 (꼭 필요한 부분만 갱신하여 내부 상태(가상 DOM)와 뷰(실제 DOM)를 같게 만듬)
            : 가상 DOM의 장점 => PhantomJS 같은 헤드리스 브라우저(GUI 없이 실행할 수 있는 브라우저) 없이도 단위 테스트가 가능

        -> React 의 폭넓은 개발 커뮤니티와 생태계
            : React의 개발 커뮤니티는 엄청나기 때문에, 대부분 직접 구현할 필요가 없음

    
    * React의 단점
        -> 모든 기능을 갖춘 프레임워크는 아님 (Redux나 Router같은 라이브러리를 함꼐 사용해야 함)
        -> 다른 프레임워크 만큼 성숙하지 않음 (아직 API의 변화가 있음)
        -> 아직 정통한 수준이 될 만한 모범 사례나 자료가 부족함
        -> 단방향 데이터 바인딩만 제공
            : 단방향 바인딩은 복잡한 앱에서 복잡도를 줄이는 데 도움을 주지만 AngularJS 같은 양방향 바인딩에 익숙한 개발자에게는 코드를 더 작상해야 하므로 불편함
        -> 리액티브 프로그래밍이라 볼 수 없음
            : 리액티브 프로그래밍 or 아키텍처는 보다 더 이벤트 기반이고, 탄력과 반응성이 뛰어남. 리액트는 옵저버블을 이용해서 비동기 데이터 스트림을 다루려면 RxJS같은 도구를 사용해야 함



    * 웹 애플리케이션에 React 적용하기
        -> React는 UI 라이브러리일 뿐이므로 어떤 형태의 백엔드나 프론트엔드 데이터 관리 라이브러리와도 함께 사용할 수 있음
        * React 라이브러리와 렌더링 대상
            -> React 커뮤니티는 여러 가지 렌더링 대상에 React를 적용할 수 잇는 패키지를 선보임 (컴포넌트 작성과 렌더링의 분리)

        * 단일 페이지 애플리케이션과 React
            -> 단일 패이지 애플리케이션(SPA) 아키텍쳐는 서버보다는 클라이언트, 즉 브라우저 측에 로직이 더 많은 팻 클라이언트
            -> SPA 아키텍처 동작 과정
                1. 사용자가 새로운 페이지를 열기 위해 브라우저에 URL 입력
                2. 브라우저가 URL 요청을 서버에 전송
                3. 서버는 응답으로 HTML, CSS, 자바스크립트 파일 같은 정적 자원을 보냄
                4. 자바스크립트 로드 후 추가로 AJAX, XHR(XMLHttpRequest, AJAX 요청을 생성하는 JavaScript API) 요청을 보내 서버에서 데이터를 불러옴
                5. 데이터는 JSON, XML 등의 포맷으로 전달받음
                6. SPA에 데이터가 전달되면 UI를 구성하는 HTML을 렌더링 함. SPA는 템플릿에 전달받은 데이터를 밀어넣고 브라우저 상에서 UI를 렌더링 함
            -> 모든 렌더링을 서버에서 해결하는 전통적인 방식과 달리 SPA에서는 데이터만 주고 받음(렌더링은 템플릿으로 HTML을 생성하는 과정)
 


 2. React 첫걸음
    * 엘리먼트 중첩
        -> 계층적 방식으로 더 복잡한 구조를 만드는 방법은 엘리먼트를 중첩하는 것
        -> 실제 DOM에 렌더링 하는 ReactDOm.render()에는 하나의 React 엘리먼트만 인자로 전달할 수 있음
        -> 동일한 DOM 계층에 요소 두 개를 렌더링 해야 하는 경우 문제가 발생
            : 시각적으로 영챵을 끼치지 않는 요소로 두 요소를 감싸는 방법으로 해결 (ex) <div> 또는 <span>을 컨테이너로 사용하는 것)
        -> createElement()에 두번째 매개변수 이후의 모든 매개변수는 자식 엘리먼트가 됨

    * React 컴포넌트 클래스 생성
        -> 컴포넌트 클래스를 이용하면 기능을 느슨하게 결합된 부분으로 분리하여 코드 재사용 가능
            * 느슨한 결합 : 다른 클래스를 직접적으로 사용하는 클래스의 의존성을 줄인 결합
        -> 추상화는 여러 팀이 거대하고 복잡한 애플리케이션에 UI를 재사용하는 것은 물론, 다른 프로젝트에서도 재사용 가능
        -> ES6 문법을 이용하면 React.Component 클래스를 상속받아서 React 컴포넌트 클래스 생성 가능

    * React 속성 사용하기
        -> React 컴포넌트의 속성(Props)은 React 선언형 스타일의 기초 (속성은 컴포넌트 내부에서 변경할 수 없는 값)
        -> <TAG_NAME PROPERTY_NAME=VALUE/>
        -> Props의 용도
            : 일반적인 HTML요소의 속성 (href, titile, style, class etc,,,)
            : React 컴포넌트 클래스의 자바스크립트 코드에서 this.props의 값
            ** 일치하는 HTML 속성이 있으면 해당 엘리먼트의 HTML 속성으로 사용 / 입력한 속성의 이름이 PROPERTY_NAME 이라면 컴포넌트 클래스 코드에서는 this.porps.PROPERTY_NAME으로 접근 가능
            ** 표준 HTML 속성명과 일치하지 않는다면 속성명 이 표준 속성이 아닌것 (HTML에 렌더링 하지 않음) / But, 이 값은 this.props.PROPERTY_NAME 같은 방식으로 접근 가능
        -> 같은 컴포넌트에 다른 속성 값을 입력하면 컴포넌트가 렌더링한 엘리먼트의 모습을 다르게 할 수 있음
        -> 컴포넌트 render() 메서드 내에서 this.props 객체에 접근하면 createElement()의 두번째 매개변수로 전달한 객체에 접근할 수 있음
        -> React.createElement()의 두번째 인자로 전달하는 키-값 쌍의 수는 제한이 없음
        -> 컴포넌트의 모든 속성을 자식 엘리먼트에 넘겨주는 것이 가능